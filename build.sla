#
# This is a script containing functions that are used as build rules. You can
# use the Simple Little Automator (https://github.com/fboender/sla.git) to run
# these rules, or you can run them directly in your shell:
#
#   $ bash -c ". build.sla && test"
#

PROG="jerrybuild"

_section () {
    PREV_SHOPT="$(set +o)"
    set +x
    echo "────────────────────────────────────────────────────────────────────────"
    echo $*
    echo "────────────────────────────────────────────────────────────────────────"
    eval "$PREV_SHOPT"
}

_clean_release_bin () {
    # Clean files generated by release_bin
    rm -f ${PROG}bin.py
    rm -rf ${PROG}bin.spec
    rm -rf build
    rm -rf $PROG-$REL_VERSION-bin64
    rm -rf __pycache__
}

_clean_release_wheel () {
    # Clean files generated by release_wheel
    rm -rf build
    rm -rf *.egg-info
}

clean () {
    # Remove build artifacts and other trash
    find ./ -name "*.pyc" -delete
    find ./ -name "__pycache__" -type d -delete
    find ./ -name "*.log" -delete

    # Remove generated test and example files
    rm -rf example/status/jobs/_all/*
    rm -rf example/status/jobs/example/*
    rm -rf example/work_dir/jerrybuild

    # Remove release stuff
    rm -rf dist
    _clean_release_wheel
    _clean_release_bin
}

test () {
    # All tests
    test_lint
    test_build
    test_units
}

test_build () {
    # Test running myexample from git repo and installed version
    clean
    pip -q uninstall -y ${PROG}

    # Run from repo
    ./myexample.py a b

    # Run from package
    ./setup.py -q bdist_wheel
    pip -q install dist/*.whl
    ${PROG} a b
    pip -q uninstall -y ${PROG}

    # Clean up
    rm -rf *.egg-info
    rm -rf build
    rm -rf dist
}

test_lint () {
    # Linting tests

    # Code quality linting (flake8)
    # E402 == module level import not at top of file
    flake8 --extend-ignore=E402 $PROG/*.py

    # Code quality linting (pylint)
    pylint --reports=n -dR -d star-args -d no-member $PROG/*.py || true
}

test_units () {
    # Unit tests
    python tests/tests.py
}

_release_check() {
    # Verify and prepare for release

    # Only run this rule once
    if [ -z "$RELEASE_CHECK_DONE" ]; then
        RELEASE_CHECK_DONE=1

        _section "release_check: Verifying release requirements"

        # Check that REL_VERSION is set
        if [ ! -z "$REL_VERSION" ]; then
            # Already set. No-op
            :
        elif [ ! -z "$1" ]; then
            REL_VERSION="$1"
            shift
        else
            echo "REL_VERSION not set. Aborting" >&2
            exit 1
        fi

        # Check version semantics
        if [ $(echo $REL_VERSION | cut -c 1) = "v" ]; then
            echo "REL_VERSION shouldn't start with 'v'" >&2
            exit 1
        fi

        # Check that version hasn't been used before
        if [ $(git tag -l | grep "^$$REL_VERSION$") ]; then
            echo "$REL_VERSION already exists as a tag" >&2
            exit 1
        fi

        # Prepare project for release
        clean

        # Bump version number
        sed -i "s/\"version\": \".*\"/\"version\": \"$REL_VERSION\"/" $PROG/__init__.py
    fi
}

release_wheel () {
    # Build wheel release
    # Build a bdist_wheel release. Mostly for testing. It needs to manually be
    # uploaded to PyPi using:
    #
    #     twine upload dist/*.whl
    #
    _release_check "$*"

    # Generate wheel (mostly for testing)
    _section "release_wheel: Generating python wheel dist"
    ./setup.py bdist_wheel

    # Cleanup
    _section "relaase_wheel: Cleanup"
    _clean_release_wheel
}

release_bin () {
    # Build binary release
    # Build a standalone binary using pyinstaller. We do this using docker and
    # an image of an old OS (Ubuntu 16.04). This way we get an old Glic, which
    # ensures the binary will run on as many platforms as possible.
    _release_check "$*"

    _section "relaase_bin: Building standalone binary docker image"
    DOCKER_NAME="${PROG}-binbuild"
    docker build -t "$DOCKER_NAME" -f .Dockerfile.binbuild .

    # Copy main program because PyInstaller doesn't like the name conflict
    # between the python file and the module dir apparently.
    _section "relaase_bin: Building standalone binary"
    cp ${PROG}.py ${PROG}bin.py
    docker run \
        --user 1000:1000 \
        -it \
        -v "$(pwd)":/src \
        --rm \
        --name $DOCKER_NAME $DOCKER_NAME:latest \
        /bin/bash -c "cd /src && pyinstaller --strip --onefile ${PROG}bin.py"

    # Generate tarball
    _section "relaase_bin: Generating standalone binary tarball release"
    mkdir -p $PROG-$REL_VERSION-bin64/bin
    mkdir -p $PROG-$REL_VERSION-bin64/lib/$PROG
    mv dist/${PROG}bin $PROG-$REL_VERSION-bin64/bin/$PROG
    cp -ar data/* $PROG-$REL_VERSION-bin64/lib/$PROG
    tar -vczf dist/$PROG-$REL_VERSION-bin64.tar.gz $PROG-$REL_VERSION-bin64
    echo "Generated $PROG-$REL_VERSION-bin64.tar.gz"

    # Cleanup
    _section "relaase_bin: Cleanup"
    _clean_release_bin
}

release () {
    # Build all releases
    # Build a standalone binary and python wheel release. Releases will be put
    # in the 'dist' folder.You must specify the version as an argument or
    # environment variable. E.g.:
    #
    #   $ sla release 1.3
    #   $ REL_VERSION=1.3 sla release
    #
    # Standalone binaries are built in docker. See the help output of
    # `release_bin` for more info.

    _release_check "$*"
    release_bin "$*"
    release_wheel "$*"
}
