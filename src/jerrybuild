#!/usr/bin/python

import os
import sys
import logging
import signal

import tools
import vacuum
import build_queue as bq
from jobdef_manager import JobDefManager
import jobdef_manager
import bottle
from bottle import request
import wsgi_server
import routes
import socket


class DepInjector:
    """
    Dependency injector plugin for the Bottle framework.
    """
    name = 'depinject'
    api = 2

    def __init__(self):
        self._deps = {}

    def add_dep(self, name, dep):
        self._deps[name] = dep

    def apply(self, callback, route):
        def wrapper(*args, **kwargs):
            request.deps = self._deps
            body = callback(*args, **kwargs)
            return body
        return wrapper


def load_providers(paths):
    providers = {}
    for path in paths:
        for fname in os.listdir(path):
            if not fname.endswith('.py'):
                continue
            try:
                mod_path = path
                mod_name = os.path.splitext(fname)[0]
                sys.path.insert(0, mod_path)
                try:
                    module = __import__(mod_name)
                finally:
                    sys.path.pop(0)
                providers[mod_name] = module
            except Exception as err:
                logging.exception(err)
    return providers

def sig_hup_handler_generate(jobdef_manager):
    """
    Closure that returns a HUP signal handler that reloads the configuration
    file.
    """
    def sig_hup_handler(signum, frame):
        jobdef_manager.reload()
        bottle.TEMPLATES.clear()
    return sig_hup_handler


def job_changed_handler_generate(smtp_server, server_url):
    """
    Closure that returns a Job Changed handler. The Job Changed handler is
    called by the build queue whenever the job exit code changes from the
    previous build.
    """
    def job_changed_handler(cur_job, prev_job):
        """
        Send email if a job fails the first time or when it recovers (builds
        succesfully again).
        """
        if cur_job.exit_code != 0 and cur_job.exit_code != prev_job.exit_code:
            logging.info("{}: failed. Sending emails to {}".format(cur_job, ', '.join(cur_job.mail_to)))
            subject = "Build job '{}' (id={}..) failed with exit code {}".format(cur_job.jobdef_name.encode('utf8'),
                                                                                 cur_job.id[:8],
                                                                                 cur_job.exit_code)
        elif cur_job.exit_code == 0 and cur_job.exit_code != prev_job.exit_code:
            logging.info("{}: recovered. Sending emails to {}".format(cur_job, ', '.join(cur_job.mail_to)))
            subject = "Build job '{}' (id={}..) recovered".format(cur_job.jobdef_name.encode('utf8'),
                                                                  cur_job.id[:8],
                                                                  cur_job.exit_code)
            job_url = server_url + '/job/status/' + cur_job.id
            msg = "Host = {}\n" \
                  "Exit code = {}.\n\n" \
                  "View the full job: {}.\n\n" \
                  "OUTPUT\n======\n\n{}\n\n".format(socket.getfqdn(),
                                                    cur_job.exit_code,
                                                    job_url,
                                                    cur_job.output.encode('utf8'))
        tools.mail(cur_job.mail_to, subject, msg, smtp_server=smtp_server)
        logging.info("{}: Emails sent".format(cur_job))
    return job_changed_handler


if __name__ == "__main__":
    if len(sys.argv) < 2 or '--help' in sys.argv:
        sys.stderr.write("Usage: {} <config.cfg>\n".format(sys.argv[0]))
        sys.exit(1)

    config = tools.config_load(sys.argv[1])

    log_level = logging.INFO
    if config.has_option('server', 'log_level'):
        log_level_str = config.get('server', 'log_level')
        log_level_int = getattr(logging, log_level_str.upper(), None)
        if not isinstance(log_level_int, int):
            raise ValueError('Invalid log level: %s' % log_level_str)
        log_level = log_level_int

    logging.basicConfig(level=log_level,
                        format='%(asctime)s:%(levelname)s:%(message)s')

    # Initialize the job changed handler, which will send an email when a job
    # failed. It's triggered by the job queue.
    state_dir = config.get('server', 'state_dir')
    smtp_server = '127.0.0.1'
    if config.has_option('server', 'smtp_server'):
        smtp_server = config.get('server', 'smtp_server')
    server_url = 'http://' + socket.getfqdn()
    if config.has_option('server', 'server_url'):
        server_url = config.get('server', 'server_url')
    job_changed_handler = job_changed_handler_generate(smtp_server, server_url)

    # Initialize the build queue
    build_queue = bq.BuildQueue(state_dir, job_changed_handler)
    build_queue.start()

    # Initialize the Job Definition Manager
    jobdef_manager = JobDefManager(sys.argv[1])

    # Start the vacuumer
    vacuum = vacuum.Vacuum(jobdef_manager.get_jobdefs(), build_queue)
    vacuum.start()

    # Setup a SIGHUP signal handler that reloads configuration
    signal.signal(signal.SIGHUP, sig_hup_handler_generate(jobdef_manager))

    # Load the providers
    providers = load_providers([tools.bin_rel_path('providers')])

    # Set up dependency injections for the Bottle web routes.
    dep_inject = DepInjector()
    dep_inject.add_dep('build_queue', build_queue)
    dep_inject.add_dep('jobdef_manager', jobdef_manager)
    dep_inject.add_dep('config', config)
    dep_inject.add_dep('providers', providers)

    bottle.TEMPLATE_PATH.insert(0, tools.bin_rel_path('views'))
    wsgiapp = bottle.default_app()
    wsgiapp.install(dep_inject)

    httpd_listen = '0.0.0.0'
    httpd_port = 5281
    if config.has_section('server'):
        if config.has_option('server', 'listen'):
            httpd_listen = config.get('server', 'listen')
        if config.has_option('server', 'port'):
            httpd_port = int(config.get('server', 'port'))

    httpd = wsgi_server.WSGIServer(wsgiapp, listen=httpd_listen, port=httpd_port)
    logging.info("Server listening on {}:{}".format(httpd_listen, httpd_port))
    httpd.serve_forever()
